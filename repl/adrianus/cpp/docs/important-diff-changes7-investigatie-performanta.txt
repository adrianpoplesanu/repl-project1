diff --git a/repl/adrianus/cpp/.vscode/launch.json b/repl/adrianus/cpp/.vscode/launch.json
index 380bb1f..176a668 100644
--- a/repl/adrianus/cpp/.vscode/launch.json
+++ b/repl/adrianus/cpp/.vscode/launch.json
@@ -10,7 +10,7 @@
             "type": "cppdbg",
             "request": "launch",
             "program": "${workspaceFolder}/main",
-            "args": ["${workspaceFolder}/examples/test143.ad"],
+            "args": ["${workspaceFolder}/examples/test221.ad"],
             //"args": [],
             "stopAtEntry": false,
             "cwd": "${fileDirname}",
diff --git a/repl/adrianus/cpp/.vscode/settings.json b/repl/adrianus/cpp/.vscode/settings.json
index e9665ae..3b36f6a 100644
--- a/repl/adrianus/cpp/.vscode/settings.json
+++ b/repl/adrianus/cpp/.vscode/settings.json
@@ -79,7 +79,8 @@
         "*.tcc": "cpp",
         "numeric": "cpp",
         "random": "cpp",
-        "regex": "cpp"
+        "regex": "cpp",
+        "list": "cpp"
     },
     "C_Cpp.errorSquiggles": "Disabled"
 }
diff --git a/repl/adrianus/cpp/ast.cpp b/repl/adrianus/cpp/ast.cpp
index f264657..340657c 100644
--- a/repl/adrianus/cpp/ast.cpp
+++ b/repl/adrianus/cpp/ast.cpp
@@ -21,7 +21,9 @@ Ad_AST_Program::Ad_AST_Program() {
 
 Ad_AST_Program::~Ad_AST_Program() {
     for (std::vector<Ad_AST_Node*>::iterator it = statements.begin() ; it != statements.end(); ++it) {
+    //for (int i = 0; i < statements2.size; i++) {
         Ad_AST_Node *node = *it;
+        //Ad_AST_Node *node = statements2.get(i);
         free_Ad_AST_Node_memory(node);
     }
 }
@@ -633,7 +635,7 @@ Ad_AST_HashLiteral::Ad_AST_HashLiteral(Token t) {
     token = t;
 }
 
-Ad_AST_HashLiteral::Ad_AST_HashLiteral(Token t, std::map<Ad_AST_Node*, Ad_AST_Node*> p) {
+Ad_AST_HashLiteral::Ad_AST_HashLiteral(Token t, std::unordered_map<Ad_AST_Node*, Ad_AST_Node*> p) {
     type = ST_HASH_LITERAL;
     ref_count = 0;
     token = t;
@@ -641,7 +643,7 @@ Ad_AST_HashLiteral::Ad_AST_HashLiteral(Token t, std::map<Ad_AST_Node*, Ad_AST_No
 }
 
 Ad_AST_HashLiteral::~Ad_AST_HashLiteral() {
-    for(std::map<Ad_AST_Node*, Ad_AST_Node*>::iterator it = pairs.begin(); it != pairs.end(); it++) {
+    for(std::unordered_map<Ad_AST_Node*, Ad_AST_Node*>::iterator it = pairs.begin(); it != pairs.end(); it++) {
         Ad_DECREF(it->first);
         Ad_DECREF(it->second);
         free_Ad_AST_Node_memory(it->first);
diff --git a/repl/adrianus/cpp/ast.h b/repl/adrianus/cpp/ast.h
index 747d288..d67e04d 100644
--- a/repl/adrianus/cpp/ast.h
+++ b/repl/adrianus/cpp/ast.h
@@ -5,6 +5,7 @@
 #include "settings.h"
 #include <string>
 #include <vector>
+#include "listobject2.h"
 
 enum StatementType {
     ST_PROGRAM,
@@ -41,7 +42,7 @@ enum StatementType {
     ST_SUPER_EXPRESSION
 };
 
-std::map<StatementType, std::string> statement_type_map = {
+std::unordered_map<StatementType, std::string> statement_type_map = {
     {ST_PROGRAM, "Program"},
     {ST_LET_STATEMENT, "LetStatement"},
     {ST_RETURN_STATEMENT, "ReturnStatement"},
@@ -88,6 +89,7 @@ public:
 class Ad_AST_Program : public Ad_AST_Node {
 public:
     std::vector<Ad_AST_Node*> statements;
+    InternalAdList<Ad_AST_Node*> statements2;
 
     Ad_AST_Program();
     ~Ad_AST_Program();
@@ -324,11 +326,11 @@ public:
 class Ad_AST_HashLiteral : public Ad_AST_Node {
 public:
     Token token;
-    std::map<Ad_AST_Node*, Ad_AST_Node*> pairs;
+    std::unordered_map<Ad_AST_Node*, Ad_AST_Node*> pairs;
 
     Ad_AST_HashLiteral();
     Ad_AST_HashLiteral(Token);
-    Ad_AST_HashLiteral(Token, std::map<Ad_AST_Node*, Ad_AST_Node*>);
+    Ad_AST_HashLiteral(Token, std::unordered_map<Ad_AST_Node*, Ad_AST_Node*>);
     ~Ad_AST_HashLiteral();
     virtual std::string TokenLiteral();
     virtual std::string ToString();
diff --git a/repl/adrianus/cpp/builtins.cpp b/repl/adrianus/cpp/builtins.cpp
index 9f2ab41..8df055e 100644
--- a/repl/adrianus/cpp/builtins.cpp
+++ b/repl/adrianus/cpp/builtins.cpp
@@ -291,7 +291,7 @@ Ad_Object* list_builtin(std::vector<Ad_Object*> args, Environment *env, GarbageC
         Ad_Object* default_object = args[1];
         for (int i = 0; i < size; i++) {
             Ad_Object* new_object = default_object->copy(gc);
-            Ad_INCREF(new_object);
+            //Ad_INCREF(new_object);
             list_object->elements.push_back(new_object);
         }
         free_builtin_arguments(args);
@@ -404,7 +404,7 @@ Ad_Object* sleep_builtin(std::vector<Ad_Object*> args, Environment *env, Garbage
 }
 
 // TODO: Ad_Builtin_Object needs a function pointer in the constructor, which in case of len, will point to len_builtin
-std::map<std::string, Ad_Object*> builtins_map = {
+std::unordered_map<std::string, Ad_Object*> builtins_map = {
     {"len", new Ad_Builtin_Object(&len_builtin)},
     {"exit", new Ad_Builtin_Object(&exit_builtin)},
     {"print", new Ad_Builtin_Object(&print_builtin)},
@@ -452,7 +452,7 @@ void free_builtin_arguments(std::vector<Ad_Object*> args) {
 }
 
 void free_builtin_map() {
-    for (std::map<std::string, Ad_Object*>::iterator it = builtins_map.begin(); it != builtins_map.end(); ++it) {
+    for (std::unordered_map<std::string, Ad_Object*>::iterator it = builtins_map.begin(); it != builtins_map.end(); ++it) {
         // TODO: mark and sweep cleanup
         free_Ad_Object_memory(it->second); // i need to find a way to do this with gc
     }
diff --git a/repl/adrianus/cpp/environment.cpp b/repl/adrianus/cpp/environment.cpp
index b1f2c5e..17e50f2 100644
--- a/repl/adrianus/cpp/environment.cpp
+++ b/repl/adrianus/cpp/environment.cpp
@@ -12,10 +12,7 @@ Environment::Environment() {
 }
 
 Environment::~Environment() {
-    for(std::map<std::string, Ad_Object* >::const_iterator it = store.begin(); it != store.end(); ++it) {
-        // ... do nothing, no need to DECREF objects in store, garbage collector will handle them
-    }
-    for(std::map<std::string, Environment* >::const_iterator it = siblings.begin(); it != siblings.end(); ++it) {
+    for(std::unordered_map<std::string, Environment* >::const_iterator it = siblings.begin(); it != siblings.end(); ++it) {
         // TODO: do this proper, maybe mark the env for sweeping using the gc?
         Ad_DECREF(it->second);
         delete it->second;
@@ -59,31 +56,31 @@ Ad_Object* Environment::lookupConstructor() {
 
 void Environment::Set(std::string key, Ad_Object* obj) {
     if (store.find(key) != store.end()) {
-        int old_ref_count = store[key]->ref_count;
-        FreeObjectForKey(key);
+        //int old_ref_count = store[key]->ref_count;
+        //FreeObjectForKey(key);
         store[key] = obj;
-        Ad_INCREF(obj); // this should be old_ref_count
+        //Ad_INCREF(obj); // this should be old_ref_count
         return;
     }
     if (outer && outer->Check(key)) {
         outer->Set(key, obj);
         return;
     }
-    if (store.find(key) != store.end()) {
-        // delete old object if this is an over write
-        FreeObjectForKey(key);
-    }
+    //if (store.find(key) != store.end()) {
+    //    // delete old object if this is an over write
+    //    FreeObjectForKey(key);
+    //}
     store[key] = obj;
-    Ad_INCREF(obj);
+    //Ad_INCREF(obj);
 }
 
 void Environment::setLocalParam(std::string key, Ad_Object* obj) {
-    if (store.find(key) != store.end()) {
+    /*if (store.find(key) != store.end()) {
         // delete old object if this is an over write
         FreeObjectForKey(key);
-    }
+    }*/
     store[key] = obj;
-    Ad_INCREF(obj);
+    //Ad_INCREF(obj);
 }
 
 void Environment::addSibling(std::string key, Environment *env) {
@@ -106,10 +103,10 @@ void Environment::SetBootstrapEnvironment(Environment *b) {
     bootstrap = b;
 }
 
-void Environment::FreeObjectForKey(std::string key) {
+/*void Environment::FreeObjectForKey(std::string key) {
     // TODO: this method does nothig now, remove this
     Ad_DECREF(store[key]);
-}
+}*/
 
 void Environment::PrintStore(int level) {
     int k = 0;
@@ -118,9 +115,9 @@ void Environment::PrintStore(int level) {
     std::cout << "store: {";
     int size = store.size();
     int total = 0;
-    for(std::map<std::string, Ad_Object* >::const_iterator it = store.begin(); it != store.end(); ++it) {
-        std::cout << it->first << ": ";
-        std::cout << it->second->Inspect();
+    for (const std::pair<const std::string, Ad_Object*>& it : store) {
+        std::cout << it.first << ": ";
+        std::cout << it.second->Inspect();
         total++;
         if (total < size) std::cout << ", "; // hmmm, this needs to be fixed
     }
@@ -135,14 +132,14 @@ void Environment::PrintStore(int level) {
 }
 
 Ad_Object* Environment::storeToHashObject(GarbageCollector *gc) {
-    std::map<std::string, HashPair> pairs;
+    std::unordered_map<std::string, HashPair> pairs;
 
-    for(std::map<std::string, Ad_Object* >::const_iterator it = store.begin(); it != store.end(); ++it) {
+    for (const std::pair<const std::string, Ad_Object*>& it : store) {
         std::hash<std::string> hash_string;
 
-        Ad_Object *key = new Ad_String_Object(it->first);
+        Ad_Object *key = new Ad_String_Object(it.first);
         gc->addObject(key);
-        Ad_Object *value = it->second;
+        Ad_Object *value = it.second;
 
         HashPair hash_pair(key, value);
         pairs.insert(std::make_pair(std::to_string(hash_string(key->Hash())), hash_pair)); // value needs to be a HashPair
@@ -154,7 +151,7 @@ Ad_Object* Environment::storeToHashObject(GarbageCollector *gc) {
 }
 
 Ad_Object* Environment::contextToHashObject(GarbageCollector *gc) {
-    std::map<std::string, HashPair> pairs;
+    std::unordered_map<std::string, HashPair> pairs;
 
     Ad_Hash_Object *hashObject = new Ad_Hash_Object(pairs);
     gc->addObject(hashObject);
@@ -163,8 +160,8 @@ Ad_Object* Environment::contextToHashObject(GarbageCollector *gc) {
 
 std::vector<std::string> Environment::populateGetattrs() {
     std::vector<std::string> elements;
-    for(std::map<std::string, Ad_Object* >::const_iterator it = store.begin(); it != store.end(); ++it) {
-        elements.push_back(it->first);
+    for (const std::pair<const std::string, Ad_Object*>& it : store) {
+        elements.push_back(it.first);
     }
     return elements;
 }
@@ -179,12 +176,12 @@ Environment* Environment::copy(GarbageCollector *gc) {
     if (result != NULL) {
         result->bootstrap = bootstrap; // asta n-ar trebui sa se schimbe
     }
-    for(std::map<std::string, Ad_Object* >::const_iterator it = store.begin(); it != store.end(); ++it) {
+    //for (const std::pair<const std::string, Ad_Object*>& it : store) {
         //result->store[it->first] = it->second->copy(gc);
-    }
-    for(std::map<std::string, Environment* >::const_iterator it = siblings.begin(); it != siblings.end(); ++it) {
+    //}
+    //for(std::unordered_map<std::string, Environment* >::const_iterator it = siblings.begin(); it != siblings.end(); ++it) {
         //result->siblings[it->first] = it->second->copy(gc);
-    }
+    //}
     return result;
 }
 
diff --git a/repl/adrianus/cpp/environment.h b/repl/adrianus/cpp/environment.h
index 5013390..11bdb47 100644
--- a/repl/adrianus/cpp/environment.h
+++ b/repl/adrianus/cpp/environment.h
@@ -2,6 +2,7 @@
 #define __ENVIRONMENT_H
 
 #include <map>
+#include <unordered_map>
 #include "objects.h"
 #include "gc.h"
 
@@ -9,10 +10,10 @@ class GarbageCollector; // forward declaration for GarbageCollector
 
 class Environment {
 public:
-    std::map<std::string, Ad_Object*> store;
+    std::unordered_map<std::string, Ad_Object*> store;
     Environment* outer;
     Environment* bootstrap;
-    std::map<std::string, Environment*> siblings;
+    std::unordered_map<std::string, Environment*> siblings;
     int ref_count;
     bool isBootstrapEnvironment;
     bool isGlobalEnvironment;
diff --git a/repl/adrianus/cpp/evaluator.cpp b/repl/adrianus/cpp/evaluator.cpp
index 1bcc86d..c575296 100644
--- a/repl/adrianus/cpp/evaluator.cpp
+++ b/repl/adrianus/cpp/evaluator.cpp
@@ -14,20 +14,44 @@ Ad_Boolean_Object FALSE(false);
 
 Ad_Object* Evaluator::Eval(Ad_AST_Node* node, Environment &env) {
     switch(node->type) {
-        case ST_PROGRAM:
+        case ST_PROGRAM: {
+            /*clock_t begin1 = clock();
+            tmp_obj = EvalProgram(node, env);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_PROGRAM] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return tmp_obj;*/
             return EvalProgram(node, env);
+        }
         break;
         case ST_LET_STATEMENT: {
+            /*clock_t begin1 = clock();
+            Ad_Object* obj = Eval(((Ad_AST_LetStatement*)node)->value, env);
+            env.Set(((Ad_AST_LetStatement*)node)->name.value, obj);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_LET_STATEMENT] += double(end1 - begin1) / CLOCKS_PER_SEC;*/
             Ad_Object* obj = Eval(((Ad_AST_LetStatement*)node)->value, env);
             env.Set(((Ad_AST_LetStatement*)node)->name.value, obj);
             return NULL;
         }
         break;
         case ST_ASSIGN_STATEMENT: {
+            /*clock_t begin1 = clock();
+            tmp_obj = EvalAssignStatement(node, env);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_ASSIGN_STATEMENT] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return tmp_obj;*/
             return EvalAssignStatement(node, env);
         }
         break;
         case ST_RETURN_STATEMENT: {
+            /*clock_t begin1 = clock();
+            Ad_Object* val = Eval(((Ad_AST_ReturnStatement*)node)->value, env);
+            Ad_ReturnValue_Object* obj = new Ad_ReturnValue_Object();
+            garbageCollector->addObject(obj);
+            obj->value = val;
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_RETURN_STATEMENT] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return obj;*/
             Ad_Object* val = Eval(((Ad_AST_ReturnStatement*)node)->value, env);
             Ad_ReturnValue_Object* obj = new Ad_ReturnValue_Object();
             garbageCollector->addObject(obj);
@@ -35,30 +59,72 @@ Ad_Object* Evaluator::Eval(Ad_AST_Node* node, Environment &env) {
             return obj;
         }
         break;
-        case ST_EXPRESSION_STATEMENT:
+        case ST_EXPRESSION_STATEMENT: {
+            /*//std::cout << "§";
+            clock_t begin1 = clock();
+            if (((Ad_AST_ExpressionStatement*)node)->expression) {
+                tmp_obj = Eval(((Ad_AST_ExpressionStatement*)node)->expression, env);
+                clock_t end1 = clock();
+                eval_times_per_statement_type[ST_EXPRESSION_STATEMENT] += double(end1 - begin1) / CLOCKS_PER_SEC;
+                return tmp_obj;
+            }*/
             if (((Ad_AST_ExpressionStatement*)node)->expression) {
                 return Eval(((Ad_AST_ExpressionStatement*)node)->expression, env);
             }
+        }
         break;
         case ST_IDENTIFIER: {
+            /*clock_t begin1 = clock();
+            tmp_obj = EvalIdentifier(node, env);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_IDENTIFIER] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return tmp_obj;*/
             return EvalIdentifier(node, env);
         }
         break;
         case ST_INTEGER: {
+            /*clock_t begin1 = clock();
+            Ad_Integer_Object* obj = new Ad_Integer_Object();
+            garbageCollector->addObject(obj);
+            obj->value = ((Ad_AST_Integer*)node)->value;
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_INTEGER] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return obj;*/
             Ad_Integer_Object* obj = new Ad_Integer_Object();
             garbageCollector->addObject(obj);
             obj->value = ((Ad_AST_Integer*)node)->value;
             return obj;
         }
         break;
-        case ST_FLOAT:
+        case ST_FLOAT: {
+            /*clock_t begin1 = clock();
+            tmp_obj = EvalFloatExpression(node, env);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_FLOAT] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return tmp_obj;*/
             return EvalFloatExpression(node, env);
+        }
         break;
         case ST_BOOLEAN: {
+            /*clock_t begin1 = clock();
+            tmp_obj = NativeBoolToBooleanObject(((Ad_AST_Boolean*)node)->value);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_BOOLEAN] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return tmp_obj;*/
             return NativeBoolToBooleanObject(((Ad_AST_Boolean*)node)->value);
         }
         break;
         case ST_INFIX_EXPRESSION: {
+            /*clock_t begin1 = clock();
+            Ad_Object* left = Eval(((Ad_AST_InfixExpression*)node)->left, env);
+            Ad_Object* right = Eval(((Ad_AST_InfixExpression*)node)->right, env);
+            Ad_Object* result = EvalInfixExpression(((Ad_AST_InfixExpression*)node)->_operator, left, right);
+            // TODO: mark and sweep cleanup
+            //free_Ad_Object_memory(right);
+            //free_Ad_Object_memory(left);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_INFIX_EXPRESSION] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return result;*/
             Ad_Object* left = Eval(((Ad_AST_InfixExpression*)node)->left, env);
             Ad_Object* right = Eval(((Ad_AST_InfixExpression*)node)->right, env);
             Ad_Object* result = EvalInfixExpression(((Ad_AST_InfixExpression*)node)->_operator, left, right);
@@ -69,21 +135,45 @@ Ad_Object* Evaluator::Eval(Ad_AST_Node* node, Environment &env) {
         }
         break;
         case ST_PREFIX_EXPRESSION: {
+            /*clock_t begin1 = clock();
+            Ad_Object* right = Eval(((Ad_AST_PrefixExpression*)node)->right, env);
+            tmp_obj = EvalPrefixExpression(((Ad_AST_PrefixExpression*)node)->_operator, right);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_PREFIX_EXPRESSION] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return tmp_obj;*/
             Ad_Object* right = Eval(((Ad_AST_PrefixExpression*)node)->right, env);
             return EvalPrefixExpression(((Ad_AST_PrefixExpression*)node)->_operator, right);
         }
         break;
         case ST_IF_EXPRESSION: {
+            /*clock_t begin1 = clock();
+            tmp_obj = EvalIfExpression(node, env);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_IF_EXPRESSION] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return tmp_obj;*/
             return EvalIfExpression(node, env);
         }
         break;
         case ST_BLOCK_STATEMENT: {
+            /*clock_t begin1 = clock();
+            Ad_Object* result = EvalBlockStatement(node, env);
+            //GarbageCollectEnvironments(); // after a block statement eval is ended it's NOT safe to garbage collect the environment, a nested while/if would trigger an unwanted garbage collect
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_BLOCK_STATEMENT] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return result;*/
             Ad_Object* result = EvalBlockStatement(node, env);
             //GarbageCollectEnvironments(); // after a block statement eval is ended it's NOT safe to garbage collect the environment, a nested while/if would trigger an unwanted garbage collect
             return result;
         }
         break;
         case ST_FUNCTION_LITERAL: {
+            /*clock_t begin1 = clock();
+            Ad_Function_Object* obj = new Ad_Function_Object(((Ad_AST_FunctionLiteral*)node)->parameters, ((Ad_AST_FunctionLiteral*)node)->body, &env);
+            garbageCollector->addObject(obj);
+            // TODP: add obj to gc
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_FUNCTION_LITERAL] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return obj;*/
             Ad_Function_Object* obj = new Ad_Function_Object(((Ad_AST_FunctionLiteral*)node)->parameters, ((Ad_AST_FunctionLiteral*)node)->body, &env);
             garbageCollector->addObject(obj);
             // TODP: add obj to gc
@@ -91,18 +181,42 @@ Ad_Object* Evaluator::Eval(Ad_AST_Node* node, Environment &env) {
         }
         break;
         case ST_CALL_EXPRESSION: {
+            /*//std::cout << "!";
+            clock_t begin1 = clock();
+            tmp_obj = evalCallExpression(node, &env);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_CALL_EXPRESSION] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return tmp_obj;*/
             return evalCallExpression(node, &env);
         }
         break;
         case ST_WHILE_EXPRESSION: {
+            /*clock_t begin1 = clock();
+            tmp_obj = EvalWhileExpression(node, env);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_WHILE_EXPRESSION] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return tmp_obj;*/
             return EvalWhileExpression(node, env);
         }
         break;
         case ST_STRING_LITERAL: {
+            /*clock_t begin1 = clock();
+            tmp_obj = EvalString(node, env);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_STRING_LITERAL] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return tmp_obj;*/
             return EvalString(node, env);
         }
         break;
         case ST_LIST_LITERAL: {
+            /*clock_t begin1 = clock();
+            std::vector<Ad_Object*> elements = EvalExpressions(((Ad_AST_ListLiteral*)node)->elements, env);
+            Ad_List_Object* obj = new Ad_List_Object(elements);
+            //std::cout << "adding a list to gc\n";
+            garbageCollector->addObject(obj);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_LIST_LITERAL] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return obj;*/
             std::vector<Ad_Object*> elements = EvalExpressions(((Ad_AST_ListLiteral*)node)->elements, env);
             Ad_List_Object* obj = new Ad_List_Object(elements);
             //std::cout << "adding a list to gc\n";
@@ -111,14 +225,29 @@ Ad_Object* Evaluator::Eval(Ad_AST_Node* node, Environment &env) {
         }
         break;
         case ST_INDEX_EXPRESSION: {
+            /*clock_t begin1 = clock();
+            tmp_obj = evalIndexExpression(node, &env);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_INDEX_EXPRESSION] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return tmp_obj;*/
             return evalIndexExpression(node, &env);
         }
         break;
         case ST_HASH_LITERAL: {
+            /*clock_t begin1 = clock();
+            tmp_obj = EvalHashLiteral(node, env);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_HASH_LITERAL] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return tmp_obj;*/
             return EvalHashLiteral(node, env);
         }
         break;
         case ST_DEF_STATEMENT: {
+            /*clock_t begin1 = clock();
+            tmp_obj = EvalDefStatement(node, env);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_DEF_STATEMENT] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return tmp_obj;*/
             return EvalDefStatement(node, env);
         }
         break;
@@ -128,33 +257,85 @@ Ad_Object* Evaluator::Eval(Ad_AST_Node* node, Environment &env) {
         }
         break;
         case ST_CLASS_STATEMENT: {
+            /*clock_t begin1 = clock();
+            tmp_obj = EvalClassStatement(node, env);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_CLASS_STATEMENT] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return tmp_obj;*/
             return EvalClassStatement(node, env);
         }
         break;
         case ST_MEMBER_ACCESS: {
+            /*clock_t begin1 = clock();
+            tmp_obj = EvalMemberAccess(node, env);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_MEMBER_ACCESS] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return tmp_obj;*/
             return EvalMemberAccess(node, env);
         }
         break;
-        case ST_PREFIX_INCREMENT:
+        case ST_PREFIX_INCREMENT: {
+            /*clock_t begin1 = clock();
+            tmp_obj = EvalPrefixIncrement(node, env);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_PREFIX_INCREMENT] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return tmp_obj;*/
             return EvalPrefixIncrement(node, env);
+        }
         break;
-        case ST_POSTFIX_INCREMENT:
+        case ST_POSTFIX_INCREMENT: {
+            /*clock_t begin1 = clock();
+            tmp_obj = EvalPostfixIncrement(node, env);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_POSTFIX_INCREMENT] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return tmp_obj;*/
             return EvalPostfixIncrement(node, env);
+        }
         break;
-        case ST_FOR_EXPRESSION:
+        case ST_FOR_EXPRESSION: {
+            /*clock_t begin1 = clock();
+            tmp_obj = EvalForExpression(node, env);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_FOR_EXPRESSION] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return tmp_obj;*/
             return EvalForExpression(node, env);
+        }
         break;
-        case ST_BREAK_STATEMENT:
+        case ST_BREAK_STATEMENT: {
+            /*clock_t begin1 = clock();
+            tmp_obj = EvalBreakStatement(node, env);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_BREAK_STATEMENT] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return tmp_obj;*/
             return EvalBreakStatement(node, env);
+        }
         break;
-        case ST_CONTINUE_STATEMENT:
+        case ST_CONTINUE_STATEMENT: {
+            /*clock_t begin1 = clock();
+            tmp_obj = EvalContinueStatement(node, env);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_CONTINUE_STATEMENT] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return tmp_obj;*/
             return EvalContinueStatement(node, env);
+        }
         break;
-        case ST_NULL_EXPRESSION:
+        case ST_NULL_EXPRESSION: {
+            /*clock_t begin1 = clock();
+            tmp_obj = EvalNullExpression(node, env);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_NULL_EXPRESSION] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return tmp_obj;*/
             return EvalNullExpression(node, env);
+        }
         break;
-        case ST_THIS_EXPRESSION:
+        case ST_THIS_EXPRESSION: {
+            /*clock_t begin1 = clock();
+            tmp_obj = evalThisExpression(node, &env);
+            clock_t end1 = clock();
+            eval_times_per_statement_type[ST_THIS_EXPRESSION] += double(end1 - begin1) / CLOCKS_PER_SEC;
+            return tmp_obj;*/
             return evalThisExpression(node, &env);
+        }
         break;
         default:
             std::cout << "unimplemented eval for token " << statement_type_map[node->type] << "\n";
@@ -171,8 +352,10 @@ Ad_Object* Evaluator::EvalProgram(Ad_AST_Node* node, Environment &env) {
     Init();
     Ad_Object* result;
     for (std::vector<Ad_AST_Node*>::iterator it = ((Ad_AST_Program*)node)->statements.begin() ; it != ((Ad_AST_Program*)node)->statements.end(); ++it) {
+    //for (int i = 0; i < ((Ad_AST_Program*)node)->statements2.size; i++) {
         result = NULL;
         Ad_AST_Node *obj = *it;
+        //Ad_AST_Node *obj = ((Ad_AST_Program*)node)->statements2.get(i);
         result = Eval(obj, env);
         if (result != NULL) {
             //result->Print();
@@ -187,8 +370,13 @@ Ad_Object* Evaluator::EvalProgram(Ad_AST_Node* node, Environment &env) {
         if (result != NULL && result->Type() == OBJ_ERROR) {
             // TODO: mark and sweep cleanup
             //free_Ad_Object_memory(result);
-            garbageCollector->markObjects();
-            garbageCollector->sweepObjects();
+            //if (garbageCollector->cycle >= garbageCollector->CYCLE_MAX) {
+            //    garbageCollector->cycle = 0;
+                garbageCollector->markObjects();
+                garbageCollector->sweepObjects();
+            //} else {
+            //    garbageCollector->cycle++;
+            //}
             return NULL;
         }
         // TODO: mark and sweep cleanup
@@ -196,8 +384,13 @@ Ad_Object* Evaluator::EvalProgram(Ad_AST_Node* node, Environment &env) {
         // OBJ_BUILTINS get destroyed on termination by free_builtin_map
         //std::cout << statement_type_map[obj->type] << "\n";
         GarbageCollectEnvironments(); // commented this because garbage collecting after each statement might clear the environment before all the statements in the block got evaluated
-        garbageCollector->markObjects();
-        garbageCollector->sweepObjects();
+        //if (garbageCollector->cycle >= garbageCollector->CYCLE_MAX) {
+        //    garbageCollector->cycle = 0;
+            garbageCollector->markObjects();
+            garbageCollector->sweepObjects();
+        //} else {
+        //    garbageCollector->cycle++;
+        //}
     }
     return NULL;
 }
@@ -441,10 +634,12 @@ Ad_Object* Evaluator::EvalMinusPrefixOperatorExpression(Ad_Object* right) {
 Ad_Object* Evaluator::EvalIdentifier(Ad_AST_Node* node, Environment &env) {
     Ad_Object* obj;
     obj = NULL;
-    if (env.Check(((Ad_AST_Identifier*)node)->token.literal)) {
+    /*if (env.Check(((Ad_AST_Identifier*)node)->token.literal)) {
         obj = env.Get(((Ad_AST_Identifier*)node)->token.literal);
         return obj;
-    }
+    }*/
+    obj = env.Get(((Ad_AST_Identifier*)node)->token.literal);
+    if (obj != NULL) return obj;
     if (builtins_map.find(((Ad_AST_Identifier*)node)->token.literal) != builtins_map.end()) {
         return builtins_map[((Ad_AST_Identifier*)node)->token.literal];
         //return NULL;
@@ -522,6 +717,7 @@ std::vector<Ad_Object*> Evaluator::EvalExpressions(std::vector<Ad_AST_Node*> arg
 }
 
 Ad_Object* Evaluator::ApplyFunction(Ad_Object* func, std::vector<Ad_Object*> args, Environment &env) {
+    //std::cout << ".";
     if (func->type == OBJ_FUNCTION) {
         Ad_Function_Object* func_obj = (Ad_Function_Object*) func;
         if (func_obj->params.size() != args.size()) {
@@ -757,15 +953,15 @@ Ad_Object* Evaluator::EvalListIndexExpression(Ad_Object* left, Ad_Object* index)
 }
 
 Ad_Object* Evaluator::EvalHashLiteral(Ad_AST_Node* node, Environment &env) {
-    std::map<std::string, HashPair> pairs;
-    for(std::map<Ad_AST_Node*, Ad_AST_Node*>::iterator it = ((Ad_AST_HashLiteral*)node)->pairs.begin(); it != ((Ad_AST_HashLiteral*)node)->pairs.end(); ++it) {
+    std::unordered_map<std::string, HashPair> pairs;
+    for(std::unordered_map<Ad_AST_Node*, Ad_AST_Node*>::iterator it = ((Ad_AST_HashLiteral*)node)->pairs.begin(); it != ((Ad_AST_HashLiteral*)node)->pairs.end(); ++it) {
         Ad_Object* key = Eval(it->first, env);
         if (IsError(key)) {
             return key;
         }
         Ad_Object* value = Eval(it->second, env);
-        Ad_INCREF(key);
-        Ad_INCREF(value);
+        //Ad_INCREF(key);
+        //Ad_INCREF(value);
         if (IsError(value)) {
             return value;
         }
@@ -857,32 +1053,32 @@ Ad_Object* Evaluator::EvalIndexExpressionAssign(Ad_AST_Node* node, Environment &
         int idx = ((Ad_Integer_Object*)index)->value;
         Ad_Object* value = Eval(((Ad_AST_AssignStatement*)node)->value, env);
         Ad_List_Object* list_obj = (Ad_List_Object*)obj;
-        Ad_Object* old_obj = list_obj->elements[idx];
-        Ad_INCREF(value);
+        //Ad_Object* old_obj = list_obj->elements[idx];
+        //Ad_INCREF(value);
         list_obj->elements[idx] = value;
         // TODO: mark and sweep cleanup
         //free_Ad_Object_memory(index);
-        Ad_DECREF(old_obj);
+        //Ad_DECREF(old_obj);
         // TODO: mark and sweep cleanup
         //free_Ad_Object_memory(old_obj);
     }
     if (obj->Type() == OBJ_HASH) {
         std::hash<std::string> hash_string;
         Ad_Object* value = Eval(((Ad_AST_AssignStatement*)node)->value, env);
-        Ad_INCREF(index);
-        Ad_INCREF(value);
+        //Ad_INCREF(index);
+        //Ad_INCREF(value);
         HashPair hash_pair(index, value);
         Ad_Hash_Object* hash_obj = (Ad_Hash_Object*)obj;
         std::string hash = std::to_string(hash_string(index->Hash()));
 
-        std::map<std::string, HashPair>::iterator it = hash_obj->pairs.find(hash);
+        std::unordered_map<std::string, HashPair>::iterator it = hash_obj->pairs.find(hash);
 
         if (it == hash_obj->pairs.end()) {
             hash_obj->pairs.insert(std::make_pair(hash, hash_pair));
         } else {
             HashPair old_hash_pair = it->second;
-            Ad_DECREF(old_hash_pair.key);
-            Ad_DECREF(old_hash_pair.value);
+            //Ad_DECREF(old_hash_pair.key);
+            //Ad_DECREF(old_hash_pair.value);
             // TODO: mark and sweep cleanup
             //free_Ad_Object_memory(old_hash_pair.key);
             //free_Ad_Object_memory(old_hash_pair.value);
@@ -1415,7 +1611,7 @@ Ad_Object* Evaluator::EvalPostfixIncrement(Ad_AST_Node* node, Environment& env)
                 HashPair hash_pair(index_obj, new_obj);
                 std::string hash = std::to_string(hash_string(index_obj->Hash()));
 
-                std::map<std::string, HashPair>::iterator it = target->pairs.find(hash);
+                std::unordered_map<std::string, HashPair>::iterator it = target->pairs.find(hash);
 
                 if (it == target->pairs.end()) {
                     target->pairs.insert(std::make_pair(hash, hash_pair));
@@ -1432,15 +1628,40 @@ Ad_Object* Evaluator::EvalPostfixIncrement(Ad_AST_Node* node, Environment& env)
     }
     Ad_AST_Identifier* ident = (Ad_AST_Identifier*) expr->name;
     Ad_Object* old_obj = env.Get(ident->value);
+    /*if (old_obj->Type() == OBJ_INT) {
+        int value = ((Ad_Integer_Object*) old_obj)->value;
+        Ad_Integer_Object* new_obj;
+        if ("++" == expr->_operator) {
+            new_obj = new Ad_Integer_Object(value + 1);
+        }
+        if ("--" == expr->_operator) {
+            new_obj = new Ad_Integer_Object(value - 1);
+        }
+        if (new_obj != NULL) {
+            garbageCollector->addObject(new_obj);
+            env.Set(ident->value, new_obj);
+            Ad_Integer_Object* result = new Ad_Integer_Object(value);
+            garbageCollector->addObject(result);
+            return result;
+        }
+    }*/
+
     if (old_obj->Type() == OBJ_INT) {
         int value = ((Ad_Integer_Object*) old_obj)->value;
-        Ad_Integer_Object* new_obj = new Ad_Integer_Object(value + 1);
-        garbageCollector->addObject(new_obj);
-        env.Set(ident->value, new_obj);
-        Ad_Integer_Object* result = new Ad_Integer_Object(value);
-        garbageCollector->addObject(result);
-        return result;
+        if ("++" == expr->_operator) {
+            Ad_Integer_Object *result = new Ad_Integer_Object(value);
+            garbageCollector->addObject(result);
+            ((Ad_Integer_Object*) old_obj)->value++;
+            return result;
+        }        
+        if ("--" == expr->_operator) {
+            Ad_Integer_Object *result = new Ad_Integer_Object(value);
+            garbageCollector->addObject(result);
+            ((Ad_Integer_Object*) old_obj)->value--;
+            return result;
+        }
     }
+
     return &NULLOBJECT;
 }
 
@@ -1482,6 +1703,7 @@ Ad_Object* Evaluator::EvalContinueStatement(Ad_AST_Node* node, Environment& env)
 }
 
 Ad_Object* Evaluator::evalCallExpression(Ad_AST_Node* node, Environment *env) {
+    //std::cout << "#";
     Ad_AST_CallExpression *callExpression = (Ad_AST_CallExpression*) node;
     Ad_Object* func = Eval(callExpression->function, *env);
     if (IsError(func)) return func;
@@ -1491,7 +1713,8 @@ Ad_Object* Evaluator::evalCallExpression(Ad_AST_Node* node, Environment *env) {
         garbageCollector->addObject(result);
         return result;
     }
-    std::vector<Ad_Object*> args_objs = EvalExpressions(callExpression->arguments, *env);
+    std::vector<Ad_Object*> args_objs;
+    args_objs = EvalExpressions(callExpression->arguments, *env);
     if (args_objs.size() == 1 && IsError(args_objs[0])) {
         return args_objs[0];
     }
@@ -1563,4 +1786,46 @@ bool Evaluator::validateNumberOfArguments(std::vector<int> accepterNumberArgumen
 
 void Evaluator::setGarbageCollector(GarbageCollector *gc) {
     garbageCollector = gc;
+}
+
+void Evaluator::initRuntimeStatistics() {
+    eval_times_per_statement_type[ST_PROGRAM] = 0;
+    eval_times_per_statement_type[ST_LET_STATEMENT] = 0;
+    eval_times_per_statement_type[ST_RETURN_STATEMENT] = 0;
+    eval_times_per_statement_type[ST_EXPRESSION_STATEMENT] = 0;
+    eval_times_per_statement_type[ST_IDENTIFIER] = 0;
+    eval_times_per_statement_type[ST_INTEGER] = 0;
+    eval_times_per_statement_type[ST_FLOAT] = 0;
+    eval_times_per_statement_type[ST_BOOLEAN] = 0;
+    eval_times_per_statement_type[ST_INFIX_EXPRESSION] = 0;
+    eval_times_per_statement_type[ST_PREFIX_EXPRESSION] = 0;
+    eval_times_per_statement_type[ST_CALL_EXPRESSION] = 0;
+    eval_times_per_statement_type[ST_IF_EXPRESSION] = 0;
+    eval_times_per_statement_type[ST_BLOCK_STATEMENT] = 0;
+    eval_times_per_statement_type[ST_FUNCTION_LITERAL] = 0;
+    eval_times_per_statement_type[ST_WHILE_EXPRESSION] = 0;
+    eval_times_per_statement_type[ST_STRING_LITERAL] = 0;
+    eval_times_per_statement_type[ST_LIST_LITERAL] = 0;
+    eval_times_per_statement_type[ST_INDEX_EXPRESSION] = 0;
+    eval_times_per_statement_type[ST_HASH_LITERAL] = 0;
+    eval_times_per_statement_type[ST_ASSIGN_STATEMENT] = 0;
+    eval_times_per_statement_type[ST_DEF_STATEMENT] = 0;
+    eval_times_per_statement_type[ST_CLASS_STATEMENT] = 0;
+    eval_times_per_statement_type[ST_MEMBER_ACCESS] = 0;
+    eval_times_per_statement_type[ST_COMMENT] = 0;
+    eval_times_per_statement_type[ST_PREFIX_INCREMENT] = 0;
+    eval_times_per_statement_type[ST_POSTFIX_INCREMENT] = 0;
+    eval_times_per_statement_type[ST_FOR_EXPRESSION] = 0;
+    eval_times_per_statement_type[ST_BREAK_STATEMENT] = 0;
+    eval_times_per_statement_type[ST_CONTINUE_STATEMENT] = 0;
+    eval_times_per_statement_type[ST_NULL_EXPRESSION] = 0;
+    eval_times_per_statement_type[ST_THIS_EXPRESSION] = 0;
+    eval_times_per_statement_type[ST_SUPER_EXPRESSION] = 0;
+}
+
+void Evaluator::printRuntimeStatistics() {
+    std::cout << "runtime per statement types:\n";
+    for (const std::pair<const StatementType, double> info : eval_times_per_statement_type) {
+        std::cout << statement_type_map[info.first] << " ran for " << info.second << "secs\n";
+    }
 }
\ No newline at end of file
diff --git a/repl/adrianus/cpp/evaluator.h b/repl/adrianus/cpp/evaluator.h
index 2519839..8f9ec44 100644
--- a/repl/adrianus/cpp/evaluator.h
+++ b/repl/adrianus/cpp/evaluator.h
@@ -6,11 +6,15 @@
 #include "environment.h"
 #include "settings.h"
 #include "gc.h"
+#include <unordered_map>
+#include <ctime>
 
 class Evaluator {
 public:
     std::vector<Environment*> environment_garbage_collection;
     GarbageCollector *garbageCollector;
+    std::unordered_map<StatementType, double> eval_times_per_statement_type;
+    Ad_Object *tmp_obj;
 
     Ad_Object* Eval(Ad_AST_Node*, Environment&);
     Ad_Object* EvalProgram(Ad_AST_Node*, Environment&);
@@ -74,6 +78,9 @@ public:
     void addEnvironmentGarbageCollectorListener(Environment *);
     void setGarbageCollector(GarbageCollector*); // using this in eval builtin
 
+    void initRuntimeStatistics();
+    void printRuntimeStatistics();
+
 private:
     bool validateNumberOfArguments(std::vector<int>, int);
 };
diff --git a/repl/adrianus/cpp/gc.cpp b/repl/adrianus/cpp/gc.cpp
index a00710b..be68bfc 100644
--- a/repl/adrianus/cpp/gc.cpp
+++ b/repl/adrianus/cpp/gc.cpp
@@ -4,19 +4,36 @@ GarbageCollector::GarbageCollector() {
     head = NULL;
     tail = NULL;
     mainEnv = NULL;
+    //cycle = 0;
+    //CYCLE_MAX = 1000;
+    //execution_time = 0;
 }
 
 GarbageCollector::~GarbageCollector() {
     //std::cout << "when quitting garbage collector i still have " << gc_environments.size() << " environments\n";
+    //begin1 = clock();
+
     forceFreeEnvironments();
+
+    //end1 = clock();
+    //execution_time += double(end1 - begin1) / CLOCKS_PER_SEC;
+
+    //std::cout << "garbage collection time: " << execution_time << "\n";
 }
 
 void GarbageCollector::addEnvironment(Environment *env) {
+    //begin1 = clock();
+
     //std::cout << "added new environment to gc\n";
     gc_environments.push_back(env);
+
+    //end1 = clock();
+    //execution_time += double(end1 - begin1) / CLOCKS_PER_SEC;
 }
 
 void GarbageCollector::sweepEnvironments() {
+    //begin1 = clock();
+
     //std::cout << "running sweepEnvironments()\n";
     int count = 0;
     std::vector<Environment*> referencedEnvironments;
@@ -33,39 +50,74 @@ void GarbageCollector::sweepEnvironments() {
     //std::cout << "freed " << count << " environments\n";
     //std::cout << "skipped " << referencedEnvironments.size() << " environments\n";
     gc_environments = referencedEnvironments;
+
+    //end1 = clock();
+    //execution_time += double(end1 - begin1) / CLOCKS_PER_SEC;
 }
 
 void GarbageCollector::forceFreeEnvironments() {
+    //begin1 = clock();
+
     for (Environment *env : gc_environments) {
         env->ref_count = 0;
         free_Ad_environment_memory(env);
     }
+
+    //end1 = clock();
+    //execution_time += double(end1 - begin1) / CLOCKS_PER_SEC;
 }
 
 void GarbageCollector::clearAstNodes() {
+    //begin1 = clock();
+
     gc_ast_nodes.clear();
+
+    //end1 = clock();
+    //execution_time += double(end1 - begin1) / CLOCKS_PER_SEC;
 }
 
 void GarbageCollector::clearEnvironments() {
+    //begin1 = clock();
+
     gc_environments.clear();
+
+    //end1 = clock();
+    //execution_time += double(end1 - begin1) / CLOCKS_PER_SEC;
 }
 
 void GarbageCollector::clearObjects() {
+    //begin1 = clock();
+
     gc_objects.clear();
+
+    //end1 = clock();
+    //execution_time += double(end1 - begin1) / CLOCKS_PER_SEC;
 }
 
 void GarbageCollector::scheduleEnvironmentToDECREF(Environment *env) {
+    //begin1 = clock();
+
     scheduled_to_DECREF_environments.push_back(env);
+
+    //end1 = clock();
+    //execution_time += double(end1 - begin1) / CLOCKS_PER_SEC;
 }
 
 void GarbageCollector::consumeScheduledDECREFEnvironments() {
+    //begin1 = clock();
+
     for (Environment *env : scheduled_to_DECREF_environments) {
         Ad_DECREF(env);
     }
     scheduled_to_DECREF_environments.clear();
+
+    //end1 = clock();
+    //execution_time += double(end1 - begin1) / CLOCKS_PER_SEC;
 }
 
 void GarbageCollector::addObject(Ad_Object* obj) {
+    //begin1 = clock();
+
     if (obj == NULL) return;
     if (head == NULL) {
         head = tail = obj;
@@ -77,9 +129,14 @@ void GarbageCollector::addObject(Ad_Object* obj) {
         obj->next = NULL;
         tail = obj;
     }
+
+    //end1 = clock();
+    //execution_time += double(end1 - begin1) / CLOCKS_PER_SEC;
 }
 
 void GarbageCollector::markObjects() {
+    //begin1 = clock();
+
     //return;
     Ad_Object* iter = head;
     while (iter != NULL) {
@@ -88,8 +145,8 @@ void GarbageCollector::markObjects() {
     }
 
     if (mainEnv != NULL) {
-        for (std::map<std::string, Ad_Object*>::iterator it = mainEnv->store.begin(); it != mainEnv->store.end(); ++it) {
-            markObject(it->second);
+        for (const std::pair<const std::string, Ad_Object*>& it : mainEnv->store) {
+            markObject(it.second);
         }
     } else {
         //std::cout << "oops!!! nu am environment principal\n";
@@ -100,19 +157,24 @@ void GarbageCollector::markObjects() {
         //if (env->bootstrap != NULL) {
         //    // TODO: handle the bootstrap event
         //}
-        for(std::map<std::string, Ad_Object*>::iterator it = env->store.begin(); it != env->store.end(); ++it) {
-            markObject(it->second);
+        for (const std::pair<const std::string, Ad_Object*>& it : env->store) {
+            markObject(it.second);
         }
 
-        for(std::map<std::string, Environment* >::const_iterator it = env->siblings.begin(); it != env->siblings.end(); ++it) {
-            for(std::map<std::string, Ad_Object*>::iterator j = it->second->store.begin(); j != it->second->store.end(); ++j) {
-                markObject(j->second);
+        for(std::unordered_map<std::string, Environment* >::const_iterator it = env->siblings.begin(); it != env->siblings.end(); ++it) {
+            for (const std::pair<const std::string, Ad_Object*>& j : it->second->store) {
+                markObject(j.second);
             }
         }
     }
+
+    //end1 = clock();
+    //execution_time += double(end1 - begin1) / CLOCKS_PER_SEC;
 }
 
 void GarbageCollector::markObject(Ad_Object* obj) {
+    //begin1 = clock();
+
     if (obj->marked) return;
     switch (obj->type) {
         case OBJ_NULL: {
@@ -168,7 +230,7 @@ void GarbageCollector::markObject(Ad_Object* obj) {
         case OBJ_HASH: {
             obj->marked = true;
             Ad_Hash_Object *hashObject = (Ad_Hash_Object*) obj;
-            for(std::map<std::string, HashPair>::iterator it = hashObject->pairs.begin(); it != hashObject->pairs.end(); it++) {
+            for(std::unordered_map<std::string, HashPair>::iterator it = hashObject->pairs.begin(); it != hashObject->pairs.end(); it++) {
                 markObject(it->second.GetKey());
                 markObject(it->second.GetValue());
             }
@@ -184,8 +246,8 @@ void GarbageCollector::markObject(Ad_Object* obj) {
             // TODO: i need to determine what to do with the contained Environment* object
             Ad_Class_Instance *instanceObject = (Ad_Class_Instance*) obj;
             markObject(instanceObject->klass_object);
-            for (std::map<std::string, Ad_Object*>::iterator it = instanceObject->instance_environment->store.begin(); it != instanceObject->instance_environment->store.end(); ++it) {
-                markObject(it->second);
+            for (const std::pair<const std::string, Ad_Object*>& it : instanceObject->instance_environment->store) {
+                markObject(it.second);
             }
             break;
         }
@@ -219,9 +281,14 @@ void GarbageCollector::markObject(Ad_Object* obj) {
             break;
         }
     }
+
+    //end1 = clock();
+    //execution_time += double(end1 - begin1) / CLOCKS_PER_SEC;
 }
 
 void GarbageCollector::unmarkAllObjects() {
+    //begin1 = clock();
+
     Ad_Object* iter = head;
     int count = 0;
     while (iter != NULL) {
@@ -230,9 +297,14 @@ void GarbageCollector::unmarkAllObjects() {
         count++;
     }
     //std::cout << "unmarking " << count << " objects\n";
+
+    //end1 = clock();
+    //execution_time += double(end1 - begin1) / CLOCKS_PER_SEC;
 }
 
 void GarbageCollector::sweepObjects() {
+    //begin1 = clock();
+
     //return;
     Ad_Object* iter = head;
     while(iter != NULL) {
@@ -262,9 +334,17 @@ void GarbageCollector::sweepObjects() {
             //std::cout << target->Inspect() << "\n"; // asta merge daca nu fac free inainte cu metoda veche
         }
     }
+
+    //end1 = clock();
+    //execution_time += double(end1 - begin1) / CLOCKS_PER_SEC;
 }
 
 void GarbageCollector::forceFreeObjects() {
+    //begin1 = clock();
+
     unmarkAllObjects();
     sweepObjects();
+
+    //end1 = clock();
+    //execution_time += double(end1 - begin1) / CLOCKS_PER_SEC;
 }
\ No newline at end of file
diff --git a/repl/adrianus/cpp/gc.h b/repl/adrianus/cpp/gc.h
index eb106e6..fbe7f8b 100644
--- a/repl/adrianus/cpp/gc.h
+++ b/repl/adrianus/cpp/gc.h
@@ -4,6 +4,7 @@
 #include "environment.h"
 #include "objects.h"
 #include "ast.h"
+#include <ctime>
 
 class GarbageCollector {
 public:
@@ -15,6 +16,11 @@ public:
     Environment* mainEnv;
     Ad_Object* head;
     Ad_Object* tail;
+    //int cycle;
+    //int CYCLE_MAX;
+    //double execution_time;
+    //clock_t begin1;
+    //clock_t end1;
 
     GarbageCollector();
     ~GarbageCollector();
diff --git a/repl/adrianus/cpp/lexer.cpp b/repl/adrianus/cpp/lexer.cpp
index 2027554..3e1c9d3 100644
--- a/repl/adrianus/cpp/lexer.cpp
+++ b/repl/adrianus/cpp/lexer.cpp
@@ -126,8 +126,14 @@ Token Lexer::NextToken() {
             }
         break;
         case '-':
-            token.type = TT_MINUS;
-            token.literal = current_char;
+            if (PeekChar() == '-') {
+                ReadChar();
+                token.type = TT_MINUSMINUS;
+                token.literal = "--";
+            } else {
+                token.type = TT_MINUS;
+                token.literal = current_char;
+            }
         break;
         case '*':
             token.type = TT_ASTERISK;
diff --git a/repl/adrianus/cpp/main.cpp b/repl/adrianus/cpp/main.cpp
index 70f01e7..079d48d 100644
--- a/repl/adrianus/cpp/main.cpp
+++ b/repl/adrianus/cpp/main.cpp
@@ -1,5 +1,6 @@
 #include <iostream>
 #include <fstream>
+#include <ctime>
 #include "tests.cpp"
 #include "test_objects.cpp"
 #include "test_parser.cpp"
@@ -12,6 +13,9 @@
 #include "thread_utils.cpp"
 #include "thread_workers.cpp"
 
+#include "listobject2.h"
+#include "listobject2.cpp"
+
 // 0 - no test is being run ar startinme, 1 - all tests are run at startime
 #define RUN_TESTS 0
 // 0 - parser test is not run, 1 - run and print AST structure
@@ -19,7 +23,7 @@
 #define RUN_FUNCTION_LITERAL_TESTS 0
 #define RUN_LISTOBJECT_TESTS 0
 #define RUN_LIST_TESTS 0
-
+#define SHOW_RUNNING_TIME 1
 
 int main(int argc, char *argv[]) {
 	if (RUN_TESTS) {
@@ -39,6 +43,10 @@ int main(int argc, char *argv[]) {
 	if (RUN_LIST_TESTS) {
 		test_list_parsing();
 	}
+	clock_t begin;
+	if (SHOW_RUNNING_TIME) {
+		begin = clock();
+	}
 	Repl repl;
 	if (argc == 1) {
 		std::cout << "Ad interpreter [C++]... v1.0\n";
@@ -49,5 +57,10 @@ int main(int argc, char *argv[]) {
 			repl.ExecuteFile(target);
 		}
 	}
+	if (SHOW_RUNNING_TIME) {
+		clock_t end = clock();
+    	double elapsed_secs = double(end - begin) / CLOCKS_PER_SEC;
+    	std::cout << "ran for: " << elapsed_secs << "sec\n";
+	}
 	return 0;
 }
\ No newline at end of file
diff --git a/repl/adrianus/cpp/objects.cpp b/repl/adrianus/cpp/objects.cpp
index 2474879..c82ddbb 100644
--- a/repl/adrianus/cpp/objects.cpp
+++ b/repl/adrianus/cpp/objects.cpp
@@ -417,9 +417,9 @@ Ad_List_Object::Ad_List_Object(std::vector<Ad_Object*> e) {
     marked = false;
     elements = e;
     // this is not efficient
-    for (std::vector<Ad_Object*>::iterator it = elements.begin() ; it != elements.end(); ++it) {
-        Ad_INCREF(*it);
-    }
+    //for (std::vector<Ad_Object*>::iterator it = elements.begin() ; it != elements.end(); ++it) {
+    //    Ad_INCREF(*it);
+    //}
 }
 
 Ad_List_Object::~Ad_List_Object() {
@@ -474,7 +474,7 @@ Ad_Hash_Object::Ad_Hash_Object() {
     marked = false;
 }
 
-Ad_Hash_Object::Ad_Hash_Object(std::map<std::string, HashPair> p) {
+Ad_Hash_Object::Ad_Hash_Object(std::unordered_map<std::string, HashPair> p) {
     type = OBJ_HASH;
     ref_count = 0;
     marked = false;
@@ -482,7 +482,7 @@ Ad_Hash_Object::Ad_Hash_Object(std::map<std::string, HashPair> p) {
 }
 
 Ad_Hash_Object::~Ad_Hash_Object() {
-    for(std::map<std::string, HashPair>::iterator it = pairs.begin(); it != pairs.end(); it++) {
+    for(std::unordered_map<std::string, HashPair>::iterator it = pairs.begin(); it != pairs.end(); it++) {
         //Ad_DECREF(it->second.key);
         //Ad_DECREF(it->second.value);
         // TODO: mark and sweep cleanup
@@ -494,7 +494,7 @@ Ad_Hash_Object::~Ad_Hash_Object() {
 std::string Ad_Hash_Object::Inspect() {
     std::string out = "{";
     bool displayed_first = false;
-    for(std::map<std::string, HashPair>::iterator it = pairs.begin(); it != pairs.end(); it++) {
+    for(std::unordered_map<std::string, HashPair>::iterator it = pairs.begin(); it != pairs.end(); it++) {
         if (displayed_first) out += ", ";
         else displayed_first = true;
         out += it->second.key->Inspect() + ": " + it->second.value->Inspect();
@@ -516,8 +516,8 @@ std::string Ad_Hash_Object::Hash() {
 }
 
 Ad_Object* Ad_Hash_Object::copy(GarbageCollector *gc) {
-    std::map<std::string, HashPair> newPairs;
-    for(std::map<std::string, HashPair>::iterator it = pairs.begin(); it != pairs.end(); it++) {
+    std::unordered_map<std::string, HashPair> newPairs;
+    for(std::unordered_map<std::string, HashPair>::iterator it = pairs.begin(); it != pairs.end(); it++) {
         std::string key = it->first;
         Ad_Object* k = it->second.GetKey()->copy(gc);
         Ad_Object* v = it->second.GetValue()->copy(gc);
@@ -897,7 +897,7 @@ Ad_Object* Ad_Thread_Object::copy(GarbageCollector *gc) {
     return new_obj;
 }
 
-void Ad_INCREF(Ad_Object* obj) {
+/*void Ad_INCREF(Ad_Object* obj) {
     if (obj) {
         obj->ref_count++;
     }
@@ -907,7 +907,7 @@ void Ad_DECREF(Ad_Object* obj) {
     if (obj) {
         obj->ref_count--;
     }
-}
+}*/
 
 void free_Ad_Object_memory(Ad_Object* obj) {
     //return;
diff --git a/repl/adrianus/cpp/objects.h b/repl/adrianus/cpp/objects.h
index bd4b1eb..68a4fc6 100644
--- a/repl/adrianus/cpp/objects.h
+++ b/repl/adrianus/cpp/objects.h
@@ -5,12 +5,14 @@
 #include <fstream>
 #include <string>
 #include <map>
+#include <unordered_map>
 #include <vector>
 #include "ast.h"
 #include "signal.h"
 #include "hashpair.h"
 #include "settings.h"
 #include "gc.h"
+#include "listobject2.h"
 #include <thread>
 
 enum Ad_Object_Type {
@@ -35,7 +37,7 @@ enum Ad_Object_Type {
 	OBJ_CONTINUE
 };
 
-std::map<Ad_Object_Type, std::string> object_type_map = {
+std::unordered_map<Ad_Object_Type, std::string> object_type_map = {
 	{OBJ_NULL, "NULL"},
 	{OBJ_INT, "INTEGER"},
 	{OBJ_FLOAT, "FLOAT"},
@@ -245,6 +247,7 @@ class Ad_List_Object : public Ad_Object {
 public:
 	//Ad_List *elements; // forward declaration
 	std::vector<Ad_Object*> elements;
+	//InternalAdList<Ad_Object*> elements; // will this be faster?
 
 	Ad_List_Object();
 	Ad_List_Object(std::vector<Ad_Object*>);
@@ -258,10 +261,10 @@ public:
 
 class Ad_Hash_Object : public Ad_Object {
 public:
-	std::map<std::string, HashPair> pairs; // do i need a HashPair implementation also? the answer is yes, i do need it
+	std::unordered_map<std::string, HashPair> pairs; // do i need a HashPair implementation also? the answer is yes, i do need it
 
 	Ad_Hash_Object();
-	Ad_Hash_Object(std::map<std::string, HashPair>);
+	Ad_Hash_Object(std::unordered_map<std::string, HashPair>);
 	~Ad_Hash_Object();
 	virtual std::string Inspect();
 	virtual void Print();
@@ -370,8 +373,8 @@ public:
 	virtual Ad_Object* copy(GarbageCollector*); // TODO: implement this
 };
 
-void Ad_INCREF(Ad_Object*);
-void Ad_DECREF(Ad_Object*);
+//void Ad_INCREF(Ad_Object*);
+//void Ad_DECREF(Ad_Object*);
 
 void free_Ad_Object_memory(Ad_Object*);
 void print_Ad_Object(Ad_Object*);
diff --git a/repl/adrianus/cpp/parser.cpp b/repl/adrianus/cpp/parser.cpp
index e17f63b..90b0db0 100644
--- a/repl/adrianus/cpp/parser.cpp
+++ b/repl/adrianus/cpp/parser.cpp
@@ -48,6 +48,7 @@ Parser::Parser() {
     infixParseFns.insert(std::make_pair(TT_ASSIGN, &Parser::ParseAssignExpression));
     infixParseFns.insert(std::make_pair(TT_DOT, &Parser::ParseMemberAccess));
     infixParseFns.insert(std::make_pair(TT_PLUSPLUS, &Parser::ParsePostfixPlusPlus));
+    infixParseFns.insert(std::make_pair(TT_MINUSMINUS, &Parser::ParsePostfixPlusPlus));
 }
 
 Parser::~Parser() {
@@ -77,6 +78,7 @@ void Parser::ParseProgram(Ad_AST_Program &program) {
         //std::cout << current_token.ToString() << "\n";
         Ad_AST_Node *stmt = (Ad_AST_Node*)ParseStatement();
         if (stmt) program.statements.push_back(stmt);
+        //if (stmt) program.statements2.add(stmt);
         //if (stmt) PrintNode(stmt);
         NextToken();
         ++limit;
diff --git a/repl/adrianus/cpp/parser.h b/repl/adrianus/cpp/parser.h
index c41d390..8a281ea 100644
--- a/repl/adrianus/cpp/parser.h
+++ b/repl/adrianus/cpp/parser.h
@@ -5,6 +5,7 @@
 #include "ast.h"
 #include <string>
 #include <map>
+#include <unordered_map>
 #include <vector>
 
 enum PrecedenceType {
@@ -22,7 +23,7 @@ enum PrecedenceType {
     PT_MEMBERACCESS
 };
 
-std::map<TokenType, PrecedenceType> precedences = {
+std::unordered_map<TokenType, PrecedenceType> precedences = {
     {TT_ASSIGN, PT_ASSIGN},
     {TT_EQ, PT_EQUALS},
     {TT_NOT_EQ, PT_EQUALS},
@@ -40,7 +41,8 @@ std::map<TokenType, PrecedenceType> precedences = {
     {TT_LPAREN, PT_CALL},
     {TT_LBRACKET, PT_INDEX},
     {TT_DOT, PT_MEMBERACCESS},
-    {TT_PLUSPLUS, PT_PLUSPLUS}
+    {TT_PLUSPLUS, PT_PLUSPLUS},
+    {TT_MINUSMINUS, PT_PLUSPLUS}
 };
 
 class Parser {
@@ -54,9 +56,9 @@ public:
     typedef Ad_AST_Node* (Parser::*PrefixCallback)();
     typedef Ad_AST_Node* (Parser::*InfixCallback)(Ad_AST_Node*);
     typedef Ad_AST_Node* (Parser::*StatementCallback)();
-    std::map<TokenType, PrefixCallback> prefixParseFns;
-    std::map<TokenType, InfixCallback> infixParseFns;
-    std::map<TokenType, StatementCallback> statementParseFns;
+    std::unordered_map<TokenType, PrefixCallback> prefixParseFns;
+    std::unordered_map<TokenType, InfixCallback> infixParseFns;
+    std::unordered_map<TokenType, StatementCallback> statementParseFns;
 
     Parser();
     ~Parser();
diff --git a/repl/adrianus/cpp/repl.cpp b/repl/adrianus/cpp/repl.cpp
index e66ddab..50dc35f 100644
--- a/repl/adrianus/cpp/repl.cpp
+++ b/repl/adrianus/cpp/repl.cpp
@@ -7,6 +7,7 @@
 #include "bootstrap.cpp"
 #include "thread_workers.h"
 #include <thread>
+#include <ctime>
 
 Repl::Repl() {
     garbageCollector = new GarbageCollector();
@@ -44,7 +45,11 @@ void Repl::Loop() {
 }
 
 void Repl::ExecuteFile(std::ifstream &target) {
+    //clock_t begin1 = clock();
     Environment* bootstrap = load_bootstrap(program, parser, &evaluator);
+    //clock_t end1 = clock();
+    //double elapsed_secs1 = double(end1 - begin1) / CLOCKS_PER_SEC;
+    //std::cout << "eval-ul bootstrapului ran for: " << elapsed_secs1 << "sec\n";
     bootstrap->isBootstrapEnvironment = true;
 
     env = newEnvironment();
@@ -60,7 +65,14 @@ void Repl::ExecuteFile(std::ifstream &target) {
         parser.Load(text);
         program.reset();
         parser.ParseProgram(program);
+        //print_ast_nodes(&program, 0);
+        //clock_t begin = clock();
+        //evaluator.initRuntimeStatistics();
         Ad_Object* res = evaluator.Eval((Ad_AST_Node *)&program, *env); // TODO: asta cicleaza in momentul executiei fisierului la while
+        //evaluator.printRuntimeStatistics();
+        //clock_t end = clock();
+    	//double elapsed_secs = double(end - begin) / CLOCKS_PER_SEC;
+    	//std::cout << "eval-ul programului ran for: " << elapsed_secs << "sec\n";
         // in python nu cicleaza pentru ca fac .read() care ia tot continutul fisierului o data, poate la fel ar trebui sa fac si aici
         if (res && res->Type() == OBJ_SIGNAL) {
             // no need to do anything because of mark and sweep, here i used to clear up memory
diff --git a/repl/adrianus/cpp/tests.cpp b/repl/adrianus/cpp/tests.cpp
index 78c644b..f2c8f6f 100644
--- a/repl/adrianus/cpp/tests.cpp
+++ b/repl/adrianus/cpp/tests.cpp
@@ -3,7 +3,7 @@
 
 void test_keywords_map() {
 	std::cout << "testing keywords map...\n";
-	for(std::map<std::string, TokenType>::iterator it = keywords.begin(); it != keywords.end(); ++it) {
+	for(std::unordered_map<std::string, TokenType>::iterator it = keywords.begin(); it != keywords.end(); ++it) {
 		std::cout << "Key: " << it->first << '\n';
   		std::cout << "Value: " << it->second << '\n';
 	}
diff --git a/repl/adrianus/cpp/token.h b/repl/adrianus/cpp/token.h
index b1bb6d4..47b625f 100644
--- a/repl/adrianus/cpp/token.h
+++ b/repl/adrianus/cpp/token.h
@@ -3,6 +3,7 @@
 
 #include <string>
 #include <map>
+#include <unordered_map>
 
 enum TokenType {
     TT_ILLEGAL,
@@ -57,11 +58,12 @@ enum TokenType {
     TT_MULTICOMMENT,
     TT_SINGLECOMMENT,
     TT_PLUSPLUS,
+    TT_MINUSMINUS,
     TT_NULL,
     TT_SUPER
 };
 
-std::map<TokenType, std::string> token_type_map = {
+std::unordered_map<TokenType, std::string> token_type_map = {
     {TT_ILLEGAL, "ILLEGAL"},
     {TT_ASSIGN, "ASSIGN"},
     {TT_EOF, "EOF"},
@@ -114,11 +116,12 @@ std::map<TokenType, std::string> token_type_map = {
     {TT_MULTICOMMENT, "MULTICOMMENT"},
     {TT_SINGLECOMMENT, "SINGLECOMMENT"},
     {TT_PLUSPLUS, "INCREMENT_OPERATOR"},
+    {TT_MINUSMINUS, "DECREMENT_OPERATOR"},
     {TT_NULL, "NULL"},
     {TT_SUPER, "SUPER"}
 };
 
-std::map<std::string, TokenType> keywords = {
+std::unordered_map<std::string, TokenType> keywords = {
     {"let", TT_LET},
     {"return", TT_RETURN},
     {"break", TT_BREAK},
